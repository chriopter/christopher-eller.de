<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Big Bang</title>
    <style>
        body {
            margin: 0;
            background: radial-gradient(ellipse at center, #0a0a2e 0%, #000000 100%);
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
        canvas {
            display: block;
        }
        .phase-indicator {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.9);
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            pointer-events: none;
            transition: all 0.5s ease;
        }
        .subtitle {
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            letter-spacing: 2px;
            pointer-events: none;
        }
        .time-control {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .time-slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            border-radius: 2px;
        }
        .time-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: white;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        .time-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: white;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        .play-button {
            background: none;
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .play-button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: white;
        }
    </style>
</head>
<body>
    <div class="subtitle">13.8 BILLION YEARS IN 30 SECONDS</div>
    <div class="phase-indicator" id="phase">SINGULARITY</div>
    <div class="time-control">
        <button class="play-button" id="playBtn">▶</button>
        <input type="range" class="time-slider" id="timeSlider" min="0" max="1" step="0.001" value="0">
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "./node_modules/three/build/three.module.js",
                "three/addons/": "./node_modules/three/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Simulation parameters
        const PARTICLE_COUNT = 50000;
        const CYCLE_DURATION = 30000; // 30 seconds in milliseconds
        let startTime = Date.now();
        let isPlaying = true;
        let progress = 0;

        // Phase definitions
        const phases = [
            { name: 'SINGULARITY', start: 0, end: 0.05, color: new THREE.Color(1, 1, 1) },
            { name: 'INFLATION', start: 0.05, end: 0.15, color: new THREE.Color(1, 0.8, 0.3) },
            { name: 'PARTICLE ERA', start: 0.15, end: 0.3, color: new THREE.Color(0.5, 0.7, 1) },
            { name: 'NUCLEOSYNTHESIS', start: 0.3, end: 0.45, color: new THREE.Color(1, 0.5, 0.2) },
            { name: 'FIRST STARS', start: 0.45, end: 0.6, color: new THREE.Color(0.8, 0.8, 1) },
            { name: 'GALAXY FORMATION', start: 0.6, end: 0.8, color: new THREE.Color(0.6, 0.4, 0.9) },
            { name: 'PRESENT DAY', start: 0.8, end: 1.0, color: new THREE.Color(0.3, 0.5, 0.8) }
        ];

        // Create particles
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const sizes = new Float32Array(PARTICLE_COUNT);
        const velocities = new Float32Array(PARTICLE_COUNT * 3);
        const originalPositions = new Float32Array(PARTICLE_COUNT * 3);

        // Initialize particles
        for(let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;

            // Start at singularity
            positions[i3] = 0;
            positions[i3 + 1] = 0;
            positions[i3 + 2] = 0;

            // Random explosion direction
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const speed = 0.5 + Math.random() * 2;

            velocities[i3] = Math.sin(phi) * Math.cos(theta) * speed;
            velocities[i3 + 1] = Math.sin(phi) * Math.sin(theta) * speed;
            velocities[i3 + 2] = Math.cos(phi) * speed;

            // Initial white color
            colors[i3] = 1;
            colors[i3 + 1] = 1;
            colors[i3 + 2] = 1;

            // Varying sizes
            sizes[i] = Math.random() * 3 + 0.5;

            // Store original positions for galaxy formation
            const galaxyRadius = 15 + Math.random() * 25;
            const galaxyTheta = Math.random() * Math.PI * 2;
            originalPositions[i3] = Math.cos(galaxyTheta) * galaxyRadius;
            originalPositions[i3 + 1] = (Math.random() - 0.5) * 10;
            originalPositions[i3 + 2] = Math.sin(galaxyTheta) * galaxyRadius;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // Custom shader for glowing particles
        const shaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                phase: { value: 0 }
            },
            vertexShader: `
                attribute float size;
                varying vec3 vColor;
                uniform float time;

                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                uniform float phase;

                void main() {
                    vec2 center = gl_PointCoord - vec2(0.5);
                    float dist = length(center);

                    if(dist > 0.5) discard;

                    float glow = 1.0 - dist * 2.0;
                    glow = pow(glow, 2.0);

                    vec3 finalColor = vColor * (0.5 + phase * 0.5);
                    float alpha = glow * (0.7 + phase * 0.3);

                    gl_FragColor = vec4(finalColor * glow, alpha);
                }
            `,
            transparent: true,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, shaderMaterial);
        scene.add(particles);

        // Add background stars
        const starsGeometry = new THREE.BufferGeometry();
        const starsPositions = new Float32Array(2000 * 3);
        for(let i = 0; i < 2000 * 3; i += 3) {
            starsPositions[i] = (Math.random() - 0.5) * 500;
            starsPositions[i + 1] = (Math.random() - 0.5) * 500;
            starsPositions[i + 2] = (Math.random() - 0.5) * 500;
        }
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(starsPositions, 3));
        const starsMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.5,
            transparent: true,
            opacity: 0.6
        });
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // Add orbit controls for camera movement
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = true;
        controls.minDistance = 10;
        controls.maxDistance = 100;
        controls.enablePan = false;

        // Get current phase
        function getCurrentPhase(progress) {
            for(let phase of phases) {
                if(progress >= phase.start && progress < phase.end) {
                    return phase;
                }
            }
            return phases[phases.length - 1];
        }

        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Controls
        const playBtn = document.getElementById('playBtn');
        const timeSlider = document.getElementById('timeSlider');

        playBtn.addEventListener('click', () => {
            isPlaying = !isPlaying;
            playBtn.textContent = isPlaying ? '❚❚' : '▶';
            if (isPlaying) {
                startTime = Date.now() - (progress * CYCLE_DURATION);
            }
        });

        timeSlider.addEventListener('input', (e) => {
            progress = parseFloat(e.target.value);
            startTime = Date.now() - (progress * CYCLE_DURATION);
            isPlaying = false;
            playBtn.textContent = '▶';
        });

        // Start with playing
        playBtn.textContent = '❚❚';

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Calculate progress (0 to 1)
            if (isPlaying) {
                const elapsed = Date.now() - startTime;
                progress = (elapsed % CYCLE_DURATION) / CYCLE_DURATION;
                timeSlider.value = progress;
            }

            // Get current phase
            const currentPhase = getCurrentPhase(progress);
            const phaseProgress = (progress - currentPhase.start) / (currentPhase.end - currentPhase.start);

            // Update phase display
            document.getElementById('phase').textContent = currentPhase.name;

            // Update shader uniforms
            const elapsed = Date.now() - startTime;
            shaderMaterial.uniforms.time.value = elapsed * 0.001;
            shaderMaterial.uniforms.phase.value = progress;

            // Update particles
            const positions = particles.geometry.attributes.position.array;
            const colors = particles.geometry.attributes.color.array;

            for(let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;

                if(progress < 0.05) {
                    // Singularity - tight cluster with vibration
                    positions[i3] = (Math.random() - 0.5) * 0.1;
                    positions[i3 + 1] = (Math.random() - 0.5) * 0.1;
                    positions[i3 + 2] = (Math.random() - 0.5) * 0.1;

                    colors[i3] = 1;
                    colors[i3 + 1] = 1;
                    colors[i3 + 2] = 1;
                } else if(progress < 0.15) {
                    // Inflation - rapid expansion
                    const expansionSpeed = phaseProgress * 50;
                    positions[i3] = velocities[i3] * expansionSpeed;
                    positions[i3 + 1] = velocities[i3 + 1] * expansionSpeed;
                    positions[i3 + 2] = velocities[i3 + 2] * expansionSpeed;

                    colors[i3] = 1;
                    colors[i3 + 1] = 0.8 - phaseProgress * 0.3;
                    colors[i3 + 2] = 0.3 + phaseProgress * 0.4;
                } else if(progress < 0.3) {
                    // Particle era - cooling and color shift
                    const drift = 50 + phaseProgress * 20;
                    positions[i3] = velocities[i3] * drift + Math.sin(elapsed * 0.001 + i) * 0.5;
                    positions[i3 + 1] = velocities[i3 + 1] * drift + Math.cos(elapsed * 0.001 + i) * 0.5;
                    positions[i3 + 2] = velocities[i3 + 2] * drift;

                    colors[i3] = 0.5 + Math.sin(i) * 0.3;
                    colors[i3 + 1] = 0.7 + Math.cos(i) * 0.2;
                    colors[i3 + 2] = 1;
                } else if(progress < 0.6) {
                    // Structure formation - clumping
                    const targetX = originalPositions[i3] + Math.sin(elapsed * 0.0005 + i) * 2;
                    const targetY = originalPositions[i3 + 1] + Math.cos(elapsed * 0.0005 + i) * 2;
                    const targetZ = originalPositions[i3 + 2];

                    positions[i3] += (targetX - positions[i3]) * 0.02;
                    positions[i3 + 1] += (targetY - positions[i3 + 1]) * 0.02;
                    positions[i3 + 2] += (targetZ - positions[i3 + 2]) * 0.02;

                    const colorVariation = Math.sin(i * 0.1);
                    colors[i3] = 0.8 + colorVariation * 0.2;
                    colors[i3 + 1] = 0.6 + colorVariation * 0.3;
                    colors[i3 + 2] = 0.9;
                } else {
                    // Galaxy rotation
                    const angle = elapsed * 0.0001 + i * 0.01;
                    const radius = Math.sqrt(originalPositions[i3] * originalPositions[i3] +
                                            originalPositions[i3 + 2] * originalPositions[i3 + 2]);

                    positions[i3] = Math.cos(angle) * radius + Math.sin(elapsed * 0.001 + i) * 0.3;
                    positions[i3 + 1] = originalPositions[i3 + 1] + Math.sin(elapsed * 0.002 + i) * 0.5;
                    positions[i3 + 2] = Math.sin(angle) * radius;

                    // Varied star colors
                    const starType = i % 4;
                    if(starType === 0) {
                        // Blue giants
                        colors[i3] = 0.6;
                        colors[i3 + 1] = 0.7;
                        colors[i3 + 2] = 1;
                    } else if(starType === 1) {
                        // Red giants
                        colors[i3] = 1;
                        colors[i3 + 1] = 0.4;
                        colors[i3 + 2] = 0.3;
                    } else if(starType === 2) {
                        // Yellow stars
                        colors[i3] = 1;
                        colors[i3 + 1] = 0.9;
                        colors[i3 + 2] = 0.6;
                    } else {
                        // White dwarfs
                        colors[i3] = 0.9;
                        colors[i3 + 1] = 0.9;
                        colors[i3 + 2] = 1;
                    }
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;

            // Update controls
            controls.update();

            // Rotate background stars
            stars.rotation.y += 0.0001;

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>